
//====數列比對, 搜尋, 群=====
1.一個數列, 每一個元素對其他元素做比對; group 2 element; 所有可能性
-- 只取兩個數
-- 同一個位址上的數字不能重複選

for(int i=0; i<n; i++)
  for(int j=i+1; j<n; j++)
(*)當i到達(n-1)極限值, j不會執行
(*)以i為"前"base, j在i後面, 一個一個選取     
    
for(int i=0;i<n;i++)
  for(int j=0; j<i; j++)
(*)當i為0時, j不會執行
(*)以i為"後"base, j在i前面, 一個一個選取

//==== dp棋盤格問題 運算解析====
(*)以原棋盤格位置建立boundary_condition(initial_value)
- boundary_conditio(initial_value)先獨立計算, 與dp更新運算分開 
- 依據先運算好的boundary_codition來計算每一個新的dp狀態
- dp[i][j]=dp[i-1][j]+dp[i][j-1];  新狀態=舊狀態的疊加; 其中(i,j)對應到棋盤格的"實際位址"
- 最後的結果在dp[m-1][n-1]
  
(*)多建立一個memory來計算整個dp  
- 多了一個memory, 初始值是在宣告就決定了, 此初始值是虛擬初始值:
vector<vector<int>> dp(m+1,vector<int>(n+1));
  
- boundday_condition(initial_value)在dp更新中運算 (不用獨立運算)
- 一開始計算出的結果, 就是boundary_condition; boundary condition就是在dp更新中決定
- 所有的dp更新值,會比原先多shift一個位置, 但在dp更新的過程中,仍然用 "原來位址的值" 來做判斷依據
                                                         if(obstacleGrid[i-1][j-1]!=0) continue; 
                                                          obstacleGrid是原來地址
- 但, 更新之後的結果,會儲存在shift位置 
dp[i][j]=dp[i-1][j]+dp[i][j-1];
  
- 如上,在dp更新運算的過程中, 還是可用 "新狀態=舊狀態疊加"思考邏輯來解釋
- 如上,但 "新狀態" 的結果會shift一個位置
- 最後的結果在 dp[m][n]
  
//==== dp棋盤格問題 =====
概念:
(*) dp棋盤格問題, 就是"羅列所有可能(窮舉)";棋盤上每一個位址的值 => 依條件所得到每一個格子的值
(*) (a).dp上的初始值,須由input的棋盤格邊界得到 => 求極大,極小值
    (b).dp上的初始值,可以自己新增一個row, column,依據條件定義初始值

(a)
matrix                     dp  
  1,2,3      input邊界    1, 3, 6    
  4,5,6    ===========>  5   x  x   =====> min, max皆正確
  7,8,9                  12  x  x
    
(b)    
matrix                     dp  
  1,2,3     自己新增邊界   0 ,0 ,0, 0    以此方式, min會錯誤, max會正確
  4,5,6    ===========>   0  1  2  3   ====================>
  7,8,9                   0  4  x  x
                          0  7  x  x

-- 在求max, min時, 用新增邊界, 會錯誤;如b, 原因是:                          
max會正確是因為, 第二層都會選擇有數值的那一個, 而"min在第二層卻會選擇0", 因此造成錯誤                        



-- 如果要用(b)來求得max或min, 則需紀錄走的路線, 定義p[i][j],並從(1,1)開始; 
比較dp[i][j]=matrix[i][j]+(dp[i-1][j]>dp[i][j-1])?dp[i-1][j]:dp[i][j-1]; => max 路徑
    dp[i][j]=matrix[i][j]+(dp[i-1][j]<dp[i][j-1])?dp[i-1][j]:dp[i][j-1]; => min 路徑
      
p[i][j]=0代表從上面來, p[i][j]=1代表從左邊來,並利用上述關係式, 最後反推路線, 順便把對應的值加起來, 即為max或min

(*)求解順序:
1. 先建立dp二維陣列, 並依據input"在dp二維陣列上", 建立初始值
2. 運算過程中, dp會搭配"input"和"之前的dp值"來求得

  
//===== stat/DAG ====
每個小問題是一種狀態,數值範圍不同
狀態之間是單行道, 不能往回走

--------------------------------------------------------------------------                         
棋盤格降維度:
1.計數問題: 計算nxm 矩陣, 從(0,0)走到(n-1,m-1)的所有走法數
for(i=1; i<n; i++)
  for(j=1; j<m; j++)
    dp[i][j]=dp[i-1][j]+dp[i][j-1];

降維度:只用一維陣列就可以計算出最後一個數值(總數)
初始值定義 for(int i=0; i<m; ++i) dp[i]=1;
計算:  
for(int i=1; i<n; ++i)
  for(int j=1; j<m; j++)
    dp[j]=dp[j]+dp[j-1]; 
      ^    ^      ^
      |    |      |-------當層前一個數值 
      |    |--------------前一層(i-1)的數值(舊的dp[j]數值);因為在同一個column所以可以沿用
      |-------------------新的;已經運算過的dp[j]
    
圖解:
  1    1    1    1    1                 
  1    x \ 
   \      \ ---dp[j]舊的數值
    \       
     \--當層前一個數值,第一次算是由(i-1)層來定義;第二次之後就是j-1來定義  
     
x = dp[1]=dp[1] + dp[1-1];   
     新    舊      同columen的舊(第一次)     
---------------------------------------------
   1    1    1    1    1    ==>第0層      
   1    2    x \            ==>第1層
         \      \--->dp[j]舊的數
          \   
           \--->dp[j-1]同列前一個數, 不是(i-1); (i-1)是第一次計算,[0]索引  

x = dp[1]=dp[1] + dp[1-1]; =>當在index=1層,第[0]層已定義; 1,1,1,1,1   
      新    舊      同columen的舊(第一次)
-----------------------------------------------             
   1    2    3    4    5   ==>第1層
   1    3    x \           ==>第2層
         \      \--->dp[j]舊的數
          \   
           \--->dp[j-1]同列前一個數, 不是(i-1); (i-1)是第一次計算,[0]索引  

x = dp[2]=dp[2] + dp[2-1];   
      新    舊      同columen的舊             
             
//===巴斯卡三角形=====
(*)dp組合問題: 巴斯卡三角形, 
     0  1  2  3   4
0    1
1    1  1  
2    1  2  1 
3    1  3  3  1  
4    1  4  6  4   1     
n=層數 ==> 第1層index=0; 第2層index = 1

(*)方程式; 二維:
初始值 dp[i][0]=dp[i][i]=1; i=0~(n-1)

從第三層, n=index=2開始, m=index=1開始       
dp[i][j]=dp[i-1][j-1]+dp[i-1][j];  ==> i=row, j=column; 如下圖 
---i是由(i-1)推導而來 ; j是由(j-1)推導而來

1
1   1   
  \ |
   \|
1   2   1   ========> 2是由前一層的dp[i-1][j-1]=1 和 dp[i-1][j]=1
  \ | \ |
   \|  \| 
1   3   3   1 ======> 3是由前一層的dp[i-1][j-1]=1 和 dp[i-1][j]=2 

由此可推得  
  
(*)如果降維度,一維; 並以 n=2和n=3兩層來做討論

(*) FAILED; 答案錯誤; 原由:
如果以之前棋盤格計數概念來計算: 當下的值是前一個數列"往下翻"再"計算"
-- dp[i][j]=dp[i-1][j-1]+dp[i-1][j] ===> 降成一維 ===>dp[j]=dp[j-1]+dp[j];
-- 初始值定義維dp[i]=1; (i=0~n)
-- 答案會變成 1,3,4,1 而不是1,3,3,1

-- 原狀態方程 dp[i][j]=dp[i-1][j-1]+dp[i-1][j];
但降成一維, dp[j-1]是經過計算後的數值,而非未經運算的數值, 如下圖;
dp[2]=dp[2]+dp[1];
  ^--------\  
            v
dp[3]=dp[3]+dp[2];//此處的dp[2]已經在上一個運算過,而非"舊"的數值; 從狀態方程得知, dp[2];dp[j-1]是要用前一層的數值=> dp[i-1][j-1]
                  //dp[j-1]是要上一層, 而非經過運算的新數值
此處概念與dp概念;"從前面運算到後面, 後面的數值與前面有關"有點不一樣, 所以要換成另外一種方式計算    
dp[2]=dp[2]+dp[1];
dp[3]=dp[3]+dp[2]; //此處的2與上一層2有關
dp[4]=dp[4]+dp[3]; //此處的3與上一層的3有關  dp[j-1]會每次疊加
=>每一次新的計算都與前一輪計算有關; 等號左邊,會在下一論計算中變成等號右邊


(*)正確降維運算方式: 從陣列後面運算到前面:
-- 還是一樣用 dp[j]=dp[j]+dp[j-1]
-- 初始值 dp[0]=dp[1]=1; dp[2..n]=0
-- 從後面運算到前面for(int j=i; j>=1; j--)
dp[4]=dp[4]+dp[3];
dp[3]=dp[3]+dp[2];
dp[2]=dp[2]+dp[1];
等號左邊, 不會在下一論計算中變成等號右邊
  

(*)

  
(*)背: 新值(等號左邊),舊值(等號右邊)
