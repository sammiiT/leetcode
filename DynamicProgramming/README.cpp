
//====數列比對, 搜尋, 群=====
1.一個數列, 每一個元素對其他元素做比對; group 2 element; 所有可能性
-- 只取兩個數
-- 同一個位址上的數字不能重複選

for(int i=0; i<n; i++)
  for(int j=i+1; j<n; j++)
(*)當i到達(n-1)極限值, j不會執行
(*)以i為"前"base, j在i後面, 一個一個選取     
    
for(int i=0;i<n;i++)
  for(int j=0; j<i; j++)
(*)當i為0時, j不會執行
(*)以i為"後"base, j在i前面, 一個一個選取


//==== dp棋盤格問題 =====
概念:
(*) dp棋盤格問題, 就是"羅列所有可能(窮舉)";棋盤上每一個位址的值 => 依條件所得到每一個格子的值
(*) (a).dp上的初始值,須由input的棋盤格邊界得到 => 求極大,極小值
    (b).dp上的初始值,可以自己新增一個row, column,依據條件定義初始值

(a)
matrix                     dp  
  1,2,3      input邊界    1, 3, 6    
  4,5,6    ===========>  5   x  x   =====> min, max皆正確
  7,8,9                  12  x  x
    
(b)    
matrix                     dp  
  1,2,3     自己新增邊界   0 ,0 ,0, 0    以此方式, min會錯誤, max會正確
  4,5,6    ===========>   0  1  2  3   ====================>
  7,8,9                   0  4  x  x
                          0  7  x  x

-- 在求max, min時, 用新增邊界, 會錯誤;如b, 原因是:                          
max會正確是因為, 第二層都會選擇有數值的那一個, 而"min在第二層卻會選擇0", 因此造成錯誤                        



-- 如果要用(b)來求得max或min, 則需紀錄走的路線, 定義p[i][j],並從(1,1)開始; 
比較dp[i][j]=matrix[i][j]+(dp[i-1][j]>dp[i][j-1])?dp[i-1][j]:dp[i][j-1]; => max 路徑
    dp[i][j]=matrix[i][j]+(dp[i-1][j]<dp[i][j-1])?dp[i-1][j]:dp[i][j-1]; => min 路徑
      
p[i][j]=0代表從上面來, p[i][j]=1代表從左邊來,並利用上述關係式, 最後反推路線, 順便把對應的值加起來, 即為max或min

(*)求解順序:
1. 先建立dp二維陣列, 並依據input"在dp二維陣列上", 建立初始值
2. 運算過程中, dp會搭配"input"和"之前的dp值"來求得

//===== stat/DAG ====
每個小問題是一種狀態,數值範圍不同
狀態之間是單行道, 不能往回走

--------------------------------------------------------------------------                         
棋盤格降維度:




  
  
  
  
    
    
    
    
