
//====數列比對, 搜尋, 群=====
1.一個數列, 每一個元素對其他元素做比對; group 2 element; 所有可能性
-- 只取兩個數
-- 同一個位址上的數字不能重複選

for(int i=0; i<n; i++)
  for(int j=i+1; j<n; j++)
(*)當i到達(n-1)極限值, j不會執行
(*)以i為"前"base, j在i後面, 一個一個選取     
    
for(int i=0;i<n;i++)
  for(int j=0; j<i; j++)
(*)當i為0時, j不會執行
(*)以i為"後"base, j在i前面, 一個一個選取


//==== dp棋盤格問題 =====
概念:
(*) dp棋盤格問題, 就是"羅列所有可能(窮舉)";棋盤上每一個位址的值 => 依條件所得到每一個格子的值
(*) (a).dp上的初始值,須由input的棋盤格邊界得到 => 求極大,極小值
    (b).dp上的初始值,可以自己新增一個row, column,依據條件定義初始值

(a)
matrix                     dp  
  1,2,3      input邊界    1, 3, 6    
  4,5,6    ===========>  5   x  x   =====> min, max皆正確
  7,8,9                  12  x  x
    
(b)    
matrix                     dp  
  1,2,3     自己新增邊界   0 ,0 ,0, 0    以此方式, min會錯誤, max會正確
  4,5,6    ===========>   0  1  2  3   ====================>
  7,8,9                   0  4  x  x
                          0  7  x  x

-- 在求max, min時, 用新增邊界, 會錯誤;如b, 原因是:                          
max會正確是因為, 第二層都會選擇有數值的那一個, 而"min在第二層卻會選擇0", 因此造成錯誤                        



-- 如果要用(b)來求得max或min, 則需紀錄走的路線, 定義p[i][j],並從(1,1)開始; 
比較dp[i][j]=matrix[i][j]+(dp[i-1][j]>dp[i][j-1])?dp[i-1][j]:dp[i][j-1]; => max 路徑
    dp[i][j]=matrix[i][j]+(dp[i-1][j]<dp[i][j-1])?dp[i-1][j]:dp[i][j-1]; => min 路徑
      
p[i][j]=0代表從上面來, p[i][j]=1代表從左邊來,並利用上述關係式, 最後反推路線, 順便把對應的值加起來, 即為max或min

(*)求解順序:
1. 先建立dp二維陣列, 並依據input"在dp二維陣列上", 建立初始值
2. 運算過程中, dp會搭配"input"和"之前的dp值"來求得

//===== stat/DAG ====
每個小問題是一種狀態,數值範圍不同
狀態之間是單行道, 不能往回走

--------------------------------------------------------------------------                         
棋盤格降維度:
1.計數問題: 計算nxm 矩陣, 從(0,0)走到(n-1,m-1)的所有走法數
for(i=1; i<n; i++)
  for(j=1; j<m; j++)
    dp[i][j]=dp[i-1][j]+dp[i][j-1];

降維度:只用一維陣列就可以計算出最後一個數值(總數)
初始值定義 for(int i=0; i<m; ++i) dp[i]=1;
計算:  
for(int i=1; i<n; ++i)
  for(int j=1; j<m; j++)
    dp[j]=dp[j]+dp[j-1]; 
      ^    ^      ^
      |    |      |-------當層前一個數值 
      |    |--------------前一層(i-1)的數值(舊的dp[j]數值);因為在同一個column所以可以沿用
      |-------------------新的;已經運算過的dp[j]
    
圖解:
  1    1    1    1    1                 
  1    x \ 
   \      \ ---dp[j]舊的數值
    \       
     \--當層前一個數值,第一次算是由(i-1)層來定義;第二次之後就是j-1來定義  
     
x = dp[1]=dp[1] + dp[1-1];   
     新    舊      同columen的舊(第一次)     
---------------------------------------------
   1    1    1    1    1    ==>第0層      
   1    2    x \            ==>第1層
         \      \--->dp[j]舊的數
          \   
           \--->dp[j-1]同列前一個數, 不是(i-1); (i-1)是第一次計算,[0]索引  

x = dp[1]=dp[1] + dp[1-1]; =>當在index=1層,第[0]層已定義; 1,1,1,1,1   
      新    舊      同columen的舊(第一次)
-----------------------------------------------             
   1    2    3    4    5   ==>第1層
   1    3    x \           ==>第2層
         \      \--->dp[j]舊的數
          \   
           \--->dp[j-1]同列前一個數, 不是(i-1); (i-1)是第一次計算,[0]索引  

x = dp[2]=dp[2] + dp[2-1];   
      新    舊      同columen的舊             
             
             
